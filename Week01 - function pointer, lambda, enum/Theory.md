# Указатели към функции
Функциите не са по-различни от променливите в това, че те също трябва да се намират някъде в паметта. 

Ако някога сте се опитвали да принтирате функция, по погрешка или от интерес, може да сте се срещнали с подобен резултат:


```cpp
int sum(int a, int b)
{
    return a + b;
}
```
```cpp
cout << sum; 
```
Примерен изход:
```
00007FF7A0E91000
```

С други думи, когато подадем идентификаторът на функция на `cout`, ще видим адреса на тази функция.  

Разликата между променливи и функции е че променливите съдържат специфични **стойности**, а функциите - **инструкции**. Можем да направим *указател* към функция по следния начин:

```
<return type> (*<identifier>)([<type> <identifier>]);

<return type> (*<identifier>)([<type>]);
```

Това може да изглежда малко стряскащо, но ето как изглежда с по-практични примери:

```cpp
int (*foo)(int number1, int number2);

bool (*bar)(bool, int);
```

Първият пример е указател към функция, която връща int, и приема като параметри 2 int-а. Идентификатора/името на този указател е `foo`.  
Вторият пример е указател към функция, която връща bool, и приема 1 bool и 1 int. Идентификатора на този указател е `bar`.


За да присвоим някаква стойност към този указател, просто го правим както с нормална променлива:

```cpp
bool isPositive(int number)
{
    return number >= 0;
}

int main()
{
    bool (*foo)(int) = isPositive;

    cout << foo(15) << endl; // true
    cout << foo(-2);         // false
}
```
---

На практика, тази техника често се използва, когато искаме да приложим някаква функция върху много елементи на някаква колекция (напр. масив). Такива функции се наричат `map`.

```cpp
void map(int* arr, int size, int (*mappingFunction)(int))
{
    for (int i = 0; i < size; i++)
    {
        arr[i] = mappingFunction(arr[i]);
    }
}
```

Тук `mappingFunction` е указател към функция, който приема 1 int, трансформира го по някакъв начин, и връща друг int. 

Идеята е, че вместо да пишем много различни функции, които да обхождат масива и да го променят, ще напишем само 1 (`map`), а за да променим стойностите на елементите, ще пишем по-прости функции. 

```cpp
void map(int* arr, int size, int (*mappingFunction)(int))
{
    for (int i = 0; i < size; i++)
    {
        arr[i] = mappingFunction(arr[i]);
    }
}

int times2(int element)
{
    return element * 2;
}

int square(int element)
{
    return element * element;
}

int main()
{
    int arr[5] {1, 2, 3, 4, 5};
    
    map(arr, 5, times2); // 2  4  6  8  10
    map(arr, 5, square); // 4 16 36 64 100
}
```

# Ламбда изрази
Ламбда изразите са *анонимни функции*, тоест функции без име. Те са дълга и сложна тема, като на този етап ще разгледаме само по-базовите части. Ламбда функция се дефинира по следния начин

```cpp
[](){}
```

Квадратните скоби `[]` се наричат *Capture Clause*, но няма да се възползваме от него на този етап.  
Кръглите скоби `()` указват параметрите на функцията.  
Къдравите скоби `{}` са тялото на функцията.  

С други думи, по-горния код можем да го пренапишем по следния начин:

```cpp
void map(int* arr, int size, int (*mappingFunction)(int))
{
    for (int i = 0; i < size; i++)
    {
        arr[i] = mappingFunction(arr[i]);
    }
}

int main()
{
    int arr[5] {1, 2, 3, 4, 5};
    
    map(arr, 5, [](int e){return e * 2}); // 2  4  6  8  10
    map(arr, 5, [](int e){return e * e}); // 4 16 36 64 100
}
```

# Изброен тип (enum)

`enum` е начин да дефинираме множество от именувани стойности, които представляват цели числа. Използват се за по-ясен и четим код, особено когато работим със състояния, опции или флагове.

Декларираме enum по следния начин:
```cpp
enum <name>
{
    <enumerator1>,
    <enumerator2>,
    <enumerator3>,
    ...
};
```
Стойностите на енумераторите са нарастващи, започващи от 0 и от първия елемент.

Пример:
```cpp
enum Color
{
    Red,    // 0
    Green,  // 1
    Blue    // 2
}

int main()
{
    Color color = Green;
    cout << color; // 1
}
```
---
Можем да променим стойността на някой енумератор, като броенето ще продължи след него отново в нарастващ ред.

```cpp
enum ErrorCode
{
    BadRequest = 400,           // 400
    Unauthorized,               // 401
    PaymentRequired,            // 402
    Forbidden,                  // 403
    NotFound,                   // 404
    InternalServerError = 500,  // 500
    NotImplemented,             // 501
    BadGateway,                 // 502
    ServiceUnavailable          // 503
}

int main()
{
    ErrorCode code1 = NotFound; // 404

    ErrorCode code2 = 502; 
}
```

---

Този тип enum-и е проблемен по много причини, една от които е че имената на енумераторите са глобални, тоест може лесно да се случи препокриване. За да задължим програмиста да посочва от къде взима енумераторите, пишем `enum class`. За да посочим от къде взимаме дадена стойност, използваме `::`.  

Това ще ни задължи и да кастваме за да записваме/четем целочислени стойности.

```cpp
enum class Color
{
    Red,    // 0
    Green,  // 1
    Blue    // 2
}

int main()
{
    Color color = Green;        // ERROR
    Color color = Color::Green; // OK

    Color color = 1;            // ERROR
    Color color = (Color)1;     // OK

    cout << color;              // ERROR
    cout << (int)color;         // OK
}
```


